# Características

- lenguaje interpretado
- lenguaje con tipado dinámico
- lenguaje multiparadigma:
  - funcional
  - basado en prototipos
  - con soporte para objetos
- soporta ejecución asíncrona


# Tipos de datos primitivos simples

- Números (enteros y reales)
- Texto
- Booleanos


```javascript
var a;
typeof a;   // undefined

a = 23;
typeof a;   // number

a = 23.01;  
typeof a;   // number 

a = 0xff;
typeof a;   //number, hexadecimal, valor decimal: 255    

a = 0o77;
typeof a;   //number, octal, valor decimal: 63    

a = 0b1111;
typeof a;   //number, binario, valor decimal: 15    

a = true; 
typeof a;   // boolean

a = "hola mundo";
typeof a;   // string
``` 


## Texto

Existen 3 formas distintas de expresar un literal de texto:

```javascript
"Esto es una cadena de texto"
'Esto es una cadena de texto'
`Esto es una cadena de texto`
```

Las 2 primeras son equivalentes. 

```javascript
'Y me dijo: "Hola" '
"La variable 'x' no está definida"
```

La tercera forma se conoce como `template string` y fue introducida con ES2015. Permite mostrar el valor de variables y ejecutar código javascript sin tener que salir de la cadena de texto. 


Ejemplo usando `template string`

```javascript
var x = 5;

console.log ( `La variable 'x' vale ${x} unidades` );
console.log ( `El cubo de 'x' es ${Math.pow(5,3)} unidades` );
```

Ejemplo tradicional usando operador de concatenación `+`

```javascript
var x = 5;

console.log ( "La variable 'x' vale "  + x + " unidades" );
console.log ( "El cubo de 'x' es " + Math.pow(5,3) + " unidades" );
```


## Texto Unicode


## Conversión entre texto y números

```javascript 
var a = "12";       // es string
var b = "23.01";    // es string
var c = 50;         // es number

console.log ( c + c );  // 100

console.log ( c + a );             // 5012
console.log ( c + parseInt(a) );   // 62 

console.log ( a + b );             // 1223.01
console.log ( c + parseFloat(b) ); // 73.01 

c.toString();       // "50" es string
```

> ACTIVIDAD PROPUESTA: Ejecuta las siguientes sentencias y explica que hacen:
>```javascript
>    var a = "FF";
>    var b = "1010";
>
>    parseInt (a, 16);
>    
>    parseInt (b, 2);  
>    parseInt (b, 3);
>    parseInt (b, 10);
>```

## Operadores

```javascript 
var a = 11;
var b = "11";

a == b;   // true
a === b;  // false
```


# Tipos de datos primitivos compuestos

- Arrays  `[   ]`
- Objetos  `{   }`

**Javascript trata a ambos como objetos**.

## Arrays

Colección de valores separados por comas y dentro de corchetes.
En Javascript, a diferencia de otros lenguajes, los valores no tienen por que ser del mismo tipo.


```javascript
var a;

a = [ 100, 200, 23 ]; 

typeof a;              // object
a instanceof Array;    // true 

a = [ 100, "jola", true ]; 

typeof a;              // object
a instanceof Array;    // true

// Los elementos están indexados, empezando en 0
a[0]   // 100
a[1]   // "jola"
a[2]   // true

// para mostrarlos por pantalla con bucle for in
for (var i in a)  console.log (i + " ---> " + a[i]);
```


## Objetos

Colección de clave:valor separados por comas y dentro de llaves.

```javascript
var persona;

persona = { nombre:"José",  edad:30,  altura:170 };

typeof persona;              // object
persona instanceof Array;    // false

// Propiedades del objeto
persona.nombre   // "José"
persona.edad     // 30
persona.altura   // 170

// para mostrarlas por pantalla con bucle for in
for (var i in persona)  console.log (i + " ---> " + persona[i]);
```

# Funciones


# Objetos

En este apartado profundizamos en el trabajo con objetos.

- Es aconsejable inicializar los objetos cuando se crean. 
- El constructor hace esta tarea, pero en Javascript es preferible hacerlo sin usar el constructor.

```javascript
// formas permitidas, pero no recomendadas, excepto para Date()

var a = new Number();    // objeto de clase Number. A evitar. Debe usarse el tipo primitivo.
var b = new Boolean();   // objeto de clase Boolean. A evitar. Debe usarse el tipo primitivo.
var c = new String();    // objeto de clase String. A evitar. Debe usarse el tipo primitivo.
var d = new Array();     // objeto de clase Array. A evitar. Debe usarse el tipo primitivo.
var e = new Date();      // objeto de clase Date.
var f = new RegExp();    // objeto de clase RegExp. A evitar.
var g = new Function();  // objeto de clase Function. A evitar.
var h = new Object();    // objeto de clase Object genérico. A evitar.
```

```javascript
// formas recomendadas

var a = 0;               // número primitivo
var b = false;           // booleano primitivo
var c = "";              // texto primitivo
var d = [];              // objeto array  
var f = /()/;            // objeto regexp
var g = function(){};    // objeto function
var h = {};              // objeto object
```


## Arrays

**Algunos métodos interesantes**

```javascript
var numeros = []; 

numeros.lenght;                       // 0

numeros.push (100);                   // [ 100 ]
numeros.push (20, 10);                // [ 100, 20, 10 ]

var n = numeros.push (1, 1, 2, 2, 2); // [ 100, 20, 10, 1, 1, 2, 2, 2 ],  n=8 ( es la longitud )
var z = numeros.pop ();               // [ 100, 20, 10, 1, 1, 2, 2 ],  z=2 ( es el elemento extraido )

numeros.sort();                       // [1, 1, 10, 100, 2, 2, 20]
numeros.reverse();                    // [20, 2, 2, 100, 10, 1, 1]
```

> NOTA: los métodos `sort()` y `reverse()` realizan una ordenación alfábetica.
>
>```javascript
>// para realizar una ordenación númerica pasamos una función de comparación
>
>numeros.sort( function(a, b){return a-b} );     // [1, 1, 2, 2, 10, 20, 100]  
>numeros.reverse( function(a, b){return a-b} );  // [100, 20, 10, 2, 2, 2, 1, 1]
>
>// function(a, b){return a-b} ) es la función que se usará para comparar dos valores.
>```

> ACTIVIDAD PROPUESTA:
>  
>  - ¿Qué método utilizaremos para insertar un elemento al principio del array?
>  - ¿Qué método utilizaremos para extraer un elemento del principio del array?
>  
>  Puedes consultar [este enlace](https://www.w3schools.com/jsref/jsref_obj_array.asp)
  
Tres métodos muy interesantes para trabajar con arrays, y para objetos también, son:

- `map` : Realiza una operación para cada uno de los elementos
- `filter` : Filtra los elementos deseados
- `reduce` : Reduce los elementos a un valor

```javascript
// Ejemplos

var numeros = [ 1, 4, 2, 3, 5, 2, 1 ];
var cuadrados = [];
var filtrados = [];
var suma = [];

// Utilizando map para calcular el cuadrado de cada elemento
cuadrados = numeros.map( n => n * n );        // cuadrados = [ 1, 16, 4, 9, 25, 4, 1 ]  

// Utilizando filter para filtrar los elementos mayores que 2
filtrados = numeros.filter ( n => n > 2 );     // filtrados = [ 4, 3, 5 ]

// Utilizando reduce para sumar los elementos
suma = numeros.reduce ( (previo, actual) => previo + actual,  0); 
// suma = 18  (0 + 1 + 4 + 2 + 3 + 5 + 2 + 1 ) 
```

> NOTA: 
>
> - Los métodos `map`, `filter` y `reduce` reciben como primer parámetro una función callback. En este caso la hemos expresado como arrow function para simplificar el código.
> - El método `reduce` recibe un segundo parámetro que será el primer valor a utilizar.



> ACTIVIDAD PROPUESTA:
>
> - ¿Qué resultado obtenemos si ejecutamos las siguientes sentencias? 
>
> ```javascript
>    var resultado;
>    
>    resultado = filtrados.reduce ( (previo, actual) => previo + actual,  10);
>    resultado = filtrados.reduce ( (previo, actual) => previo * actual,  1);
>```


## Encadenamiento de métodos

El encadenamiento de métodos es una técnica donde aplicamos a un objeto un método. A su vez al objeto resultante se le aplica otro método. Y así sucesivamente. Nos ahorramos así el declaración de objetos intermedios y el código se simplifica.

Como requisito debemos asegurarmos que el método que aplicamos es adecuado al objeto de trabajo.

```javascript
// Ejemplo: Calculamos el doble de cada número, luego filtramos los menores de 5 y después los sumamos

resultado = numeros.map ( n => 2 * n ).filter ( n => n < 5 ).reduce ( (previo, actual) => previo + actual, 0);

// El resultado es 12
//
// - Doble de cada número: [2, 8, 4, 6, 10, 4, 2]
// - Filtro de menores de 5: [2, 4, 4, 2]
// - Suma de ellos: 12
```

```javascript
// Mismo ejemplo anterior. Para mayor legibilidad suele indicarse cada método en una línea separada
// y normalmente el punto (.) suele iniciar la línea.

resultado = numeros.map    ( n => 2 * n )
                   .filter ( n => n < 5 )
                   .reduce ( (previo, actual) => previo + actual, 0);
```


**Explicación**:

- La operación `numeros.map ( n => 2 * n )` nos devuelve el objeto literal `[2, 8, 4, 6, 10, 4, 2]`.
- Aplicamos entonces la operación `[2, 8, 4, 6, 10, 4, 2].filter ( n => n < 5 )` y obtenemos el objeto literal `[2, 4, 4, 2]`.
- Aplicamos después la operación `[2, 4, 4, 2].reduce ( (previo, actual) => previo + actual, 0)` y obtenemos `55`.
- Por último el resultado `55` se guarda en la variable `resultado`.


Si no hubieses empleado encadenamiento de métodos, el código sería el siguiente:

```javascript

var resultado1 = numeros.map ( n => 2 * n );
var resultado2 = resultado1.filter ( n => n < 5 );
var resultado3 = resultado2.reduce ( (previo, actual) => previo + actual, 0);

// resultado final en resultado3
```

El encadenamiento de métodos es una técnica que podemos utilizar siempre que sea posible y lo deseemos. Suele utilizarse frecuentemente con jQuery.


> ACTIVIDAD PROPUESTA:
>
> - ¿Qué resultado obtenemos si ejecutamos el siguiente código? 
>
>```javascript
>
>var desarrolladores = [
>  { nombre: 'Juan', tipo: 'móvil', edad: 24 },
>  { nombre: 'Inma', tipo: 'móvil', edad: 31 },
>  { nombre: 'Ana',  tipo: 'web',   edad: 25 },
>  { nombre: 'Eva',  tipo: 'web',   edad: 30 },
>  { nombre: 'José', tipo: 'móvil', edad: 33 }
>];
>
>
>var sumaEdadWeb = desarrolladores
>                 .filter ( x => x.tipo === 'web')
>                 .map    ( x => x.edad)
>                 .reduce ((previo, actual) => previo + actual, 0);
>```

> ACTIVIDAD PROPUESTA:
>
> - En lugar de calcular la suma de edades de los desarrolladores web, ¿cómo calcularíamos la media de edad de los desarrolladores web? 
 
## Date

Para trabajar con fechas debemos crear un objeto de la clase Date. 

Una forma de llamar al constructor es:

```javascript 
var fecha = new Date(año, mes, día, hora, minutos, segundos, milisegundos)
```
> IMPORTANTE: **Los meses se numeran empezando en 0**. Enero es el mes 0, Febrero el 1, ... 

```javascript 
// Ejemplos

var f1 = new Date(2017, 00, 01, 22, 30, 00, 999);  // 1 Enero de 2017, 22:30:00.999
var f2 = new Date(2017, 00, 01, 22, 30, 00);       // 1 Enero de 2017, 22:30:00
var f3 = new Date(2017, 00, 01, 22, 30);           // 1 Enero de 2017, 22:30:00
var f4 = new Date(2017, 00, 01);                   // 1 Enero de 2017, 00:00:00
```

Otra forma de llamar al constructor es:

```javascript 
var fecha = new Date("YYYY-MM-DDTHH:MI:SSZ");
```

> NOTAS: 
> 
> - **En este caso Enero sí empieza en 1**.
> - La fecha y la hora se separan con una `T` mayúscula.
> - La hora UTC (Universal Time Coordinated) o  GMT (Greenwich Mean Time) se define con una letra mayúscula `Z`.
> - **Si se crea una fecha/hora en GMT, la fecha y la hora se convertirán a la hora local del usuario**.
> - Para indicar otra zona horaria deberemos sustituir la letra Z por +HH:MI o -HH:MI 

```javascript 
// Ejemplos

var f1 = new Date("2017-01-01T23:30:00Z");        // Hora de Londres, a nosotros nos aparecerá una hora más 
var f2 = new Date("2017-01-01T23:30:00+01:00");   // Hora de España
```


## RegExp




# Referencias

- [[en inglés] Objetos](https://www.w3schools.com/js/js_objects.asp)
- [Map, Filter y Reduce](http://blog.builtbyedgar.com/javascript-map-filter-y-reduce-para-dummies/)
