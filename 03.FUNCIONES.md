# Definición e invocación 

```javascript
function suma (a, b) { return a + b; }     // Declaración o definición

suma (2, 3);                               // Llamada o invocación

typeof suma;  // "function"
```

A tener en cuenta:

- En la **declaración** de una función indicamos los **parámetros** formales, si los tiene. En este caso `a` y `b`.
- En la **llamada** a la función indicamos los parámetros reales o **argumentos**. En este caso `2`y `3`.


# Funciones anónimas

- No tienen nombre, así que **en principio no son invocables**.
- Suelen utilizarse en circunstancias donde sólo se invoca a dicha función una única vez.

```javascript
// forma tradicional
function (a, b) { return a + b; }  // ¿Cómo hago una llamada a esta función??     

// forma de función flecha 
(a, b) => { return a + b; }        // expresada en forma de función flecha
(a, b) => a + b;                   // expresada en forma de función flecha, simplificando return
```

# Formas de ejecutar una función anónima

## Mediante una expresión

- Es una forma de declarar e invocar una función, todo en un sólo paso.
- La declaración de la función se encierra entre paréntesis  `( )`
- A continuación los argumentos también se encierran entre paréntesis `( )`

```javascript
(function (a, b) { return a + b; })  (2, 3);                 
```

## A través de una variable asociada

```javascript
var suma = function (a, b) { return a + b; } ; // puedo asignarla a una variable

suma (2, 3);                                   // ahora sí puedo invocar la función a través de la variable asociada
```

## En un callback

Un **callback** es una **función que es pasada como argumento a otra función**. Dos funciones muy conocidas en Javascript, que necesitan un callback son:


```
setTimeout  ( callback,  milisegundos);   // Ejecuta el callback una sola vez después de transcurridos los ms indicados
setInverval ( callback,  milisegundos);   // Ejecuta el callback de forma recurrente cada cierto tiempo indicado en ms
```

**Ejemplo**

```javascript
// Función que usaremos para el callback. En este caso, NO es una función anónima.
function hola(){
  console.log ('Hola');
}

// La función hola será pasada como callback.
let t1 = setTimeout (hola, 5000);   // para cancelar ejecutamos clearTimeout (t1) antes del que el temporizador expire
let t2 = setInverval(hola, 5000);   // para cancelar ejecutamos clearInterval (t2) en cualquier momento
```

Una forma más compacta de escribir el código anterior es usando funciones anónimas:

```javascript
let t1 = setTimeout  ( function () { console.log ('Hola') },  5000 );  // Hacemos uso de función anónima
let t2 = setInterval ( function () { console.log ('Hola') },  5000 );  // Hacemos uso de función anónima
```

El caso anterior se puede simplificar aún más haciendo uso de `funciones flecha (arrow functions)`:

```javascript
let t1 = setTimeout  ( () => console.log ('Hola') ,  5000 );  // Hacemos uso de función anónima
let t2 = setInterval ( () => console.log ('Hola') ,  5000 );  // Hacemos uso de función anónima
```

Un caso específico a las funciones `setTimeout` y `setInterval` es que se le pueden pasar más argumentos. Todos los argumentos que aparezcan detrás de los milisegundos serán argumentos que serán pasados al callback. Por ejemplo, a continuación tenemos una función suma que utilizaremos como callback. Dicha función necesita dos argumentos para poder operar. Estos argumentos son los que escribimos como 3er y 4o argumento de `setTimeout`.

```javascript
// Función que usaremos para el callback
function suma (a, b) {  console.log ( a + b); }

setTimeout ( suma    // función a ejecutar
             , 3000  // milisegundos a esperar antes de ejecutar la función
             , 2     // primer argumento de la función 
             , 3     // segundo argumento de la función
           ) ;  
```


# Parámetros y argumentos

Javascript es un lenguaje que realiza comprobaciones menos estrictas que otros lenguajes. Esto puede a veces provocar errores en programadores que no conocen bien el lenguaje.

**Los parámetros no exigen un tipo a los argumentos**
Es posible llamar a la función *suma* con argumentos de tipo string u cualquier otro tipo.

```javascript
suma ('Hola ', 'mundo');    //  Devuelve 'Hola mundo'
```

**El número de argumentos puede ser menor que el número de parámetros declarados**
Los argumentos ausentes adquieren valor *undefined*.

```javascript
suma ('Hola ');             // Devuelve 'Hola undefined'
suma (2);                   // Devuelve NaN
```

**El número de argumentos puede ser mayor que el número de parámetros declarados**
Es posible acceder a todos los argumentos, incluidos los excedentes, a través de la variable local **arguments** disponible para cada función;

```javascript
suma ('Esto ', 'es ', 'una ', 'prueba.');    // Devuelve 'Esto es'
```
Pero si redefinimos la función como

```javascript
function suma (a, b) { 
  let s = 0;
  for (let i = 0; i < arguments.length; i++) {
    s = s + arguments[i];
  }
  return s; 
}  
```

El resultado sería

```javascript
// Funciona para cualquier número de argumentos
suma (2, 3, 4, 5, 6);                      // Devuelve 20 
suma ('Esto ', 'es ', 'una ', 'prueba.');  // Devuelve '0Esto es una prueba.'
```

> NOTA: El objeto **arguments** no es un array aunque se comporte como tal, es decir no podemos aplicarle los métodos disponibles a arrays como *sort*, *map*, ...




# Ejecución asíncrona

Utilizada frecuentemente en operaciones de Entrada/Salida:

- Lectura y escritura de información en archivos (**E/S archivos**)
- Lectura y escritura de información en base de datos (**E/S base de datos**)
- Envío y recepción de información en red (**E/S red**)

Existen 3 formas de ejecutar código de forma asíncrona. 

- Callbacks
- Promesas
- async / await

## Callbacks

Es la forma clásica y es muy habitual. 


## Promesas

Disponible a partir de ES6 (2015).

## async / await

Disponible a partir de ES7 (2016).



# Referecias

- https://carlosazaustre.es/manejando-la-asincronia-en-javascript/?utm_campaign=Revue%20newsletter&utm_medium=Newsletter&utm_source=Carlos%20Azaustre
